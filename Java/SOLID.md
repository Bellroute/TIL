# 객체지향 5대 원칙: SOLID

객체지향 프로그램의 장점은 재사용성을 통한 유지보수의 용이성과 확장성이다. 그 장점대로 객체지향 프로그래밍을 하기 위해서는 객체지향 5대 원칙이라 불리는 원칙들을 준수하는 것이 좋다.잘 알려진 입증된 객체지향 디자인패턴들은 이 원칙들을 따르고 있고, 사용하면 좀 더 유지보수하기 쉽고, 유연하고, 확장이 쉬운 소프트웨어를 만들 수 있다.

</br>

### 1. SRP (단일 책임 원칙: Single Responsibilty Principle)

> 클래스를 변경해야하는 이유는 오직 하나뿐이어야 한다.
>
> 클래스는 한가지 기능만 가지며 한가지 책임을 수행하는데 집중해야 한다.

- SRP는 책임이라는 키워드가 중요. 책임이란 변경을 위한 이유이다.
- 클래스가 변경되어야 할 여러 가지 이유가있는 경우는 클래스에 너무 많은 책임을 부여하고 있음을 의미
- SRP 원칙을 따르면 다른 행동, 책임이 격리되어 있어 연쇄적인 사이드이펙트가 발생할 여지가 줄어들고 그만큼 수정될 코드 또한 적어짐
- 하지만, 너무 많은 분할로 인하여 책임이 여러군데로 파편화 되어있는 경우에는 `산탄총 수술`로 다시 응집력을 높여줘야함.
- SRP가 안지켜진 사례
  - 변수 레벨 : 하나의 속성이 여러 의미를 갖는 경우, 어떤 곳에서는 쓰고 어떤 곳에선 안쓰는 속성이 있는 경우
  - 메소드 레벨 : 분기처리를 위한 if문이 많은 경우

`결합도(Colpuling)` : 코드의 한 요소가 다른 것과 얼마나 강력하게 연결되어 있는지. 얼마나 의존적인지 나타내는 척도. **낮은 결합도**일수록 코드 간 간섭이 심하지 않기 때문에 유지보수가 용이함.

`응집도(Cohesion)` : 한 요소가 해당 기능을 수행하기 위해 얼마나 연관된 책임과 아이디어가 뭉쳐있는지 나타내는 척도. **높은 응집도**일수록 프로그램을 쉽게 이해할 수 있고, 재사용성이 높아져 유지보수가 용이함.

- 적용 방법 - **낮은 결합도, 높은 응집도**
  - **Extract Class** : 혼재된 각 책임을 각각의 개별 클래스로 분할하여 클래스 당 하나의 책임만을 맡도록 하는 것. 여기서 관건은 책임만 분리하는 것이 아니라 분리된 두 클래스간의 관계의 복잡도를 줄이도록 설계하는 것. 
  - **Extract Superclass** : 만약 Extract Class된 각각의 클래스들이 유사하고 비슷한 책임을 중복해서 갖고 있는 경우 사용. 추출된 각각의 클래스들의 공유되는 요소를 부모 클래스로 정의하여 부모 클래스에 위임하는 기법. 유사한 책임들은 부모에게 위임하고 다른 책임들은 각자 정의할 수 있음.
  - **Shotgun surgery(산탄총 수술)** : 하나에 여러가지 책임이 있는 것의 반대인 상황으로 하나의 책임이 여러군데 분산되어있는 상황, 하나의 수정 사항이 여러군데에 영향을 미치는 경우 다시 전부 하나로 모아주어 설계를 깔끔하게 유지 시켜주도록 한다. (응집도를 높이는 것과 연관)

<br>

### 2. OCP (개방 폐쇄 원칙: Open Closed Principle)

> 소프트웨어의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에 대해서는 개방, 변경에 대해서는 폐쇄 되어야 한다.
>
> 변경에 대한 비용을 최대한 줄이면서 확장에 대해서는 가능한 극대화 해야 된다는것으로 다른 추가 사항이 일어나더라도 기존 구성은 변경하지 않으며 확장에 대한 가능성을 열어줘야 한다는 뜻

- OCP 를 가능케 하는 중요 메커니즘은 추상화와 다형성이다.
- 확장이 발생되었을때 호출하는 쪽에서 변경이 발생하지 않도록 인터페이스를 만드는것
  - 상점 직원이 아무리 바뀐다고해서 손님이 상품을 구매하는데는 지장이 없다
  - 로봇이 추가되서 공격이 다양해지더라도 기존의 공격을 수정할 필요없다
- OCP가 잘 적용된 경우 기능을 확장할 때 기존 코드를 변경할 필요가 없기 때문에 유지보수와 재사용성에 유리함.
- 적용 방법 -  **각 모듈 간 호출, 의존에 대해서 Concrete Class가 아닌 Interface 또는 추상화에 의존하도록 설계**
  - 변경(확장)될 것과 변하지 않을 것을 엄격히 구분
  - 이 두 모듈이 만나는 지점에 인터페이스를 정의
  - 구현에 의존하기보다 정의한 인터페이스에 의존하도록 코드를 작성

<br>

### 3. LSP (Liskov 치환 원칙: The Liskov Substitution Principle)

> 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다.
>
> 서브 타입은 기반 타입이 약속한 규약(public 인터페이스, 물론 메소드가 던지는 예외까지 포함됩니다.)을 지켜야 한다.

- 다형성을 통한 확장성 획득을 목표로 함.
- 다형성과 확장성을 극대화 하려면 하위 클래스를 사용하는 것보다는 상위의 클래스(인터페이스)를 사용하는 것이 더 좋음.
- 결국 이 구조는 다형성을. 통한 확장의 원리인 OCP를 제공 하게 됨.

- 적용 방법
  - 만약 두 개체가 똑 같은 일을 한다면 둘을 하나의 클래스로 표현하고 이들을 구분할 수 있는 필드를 둔다
  - 똑같은 연산을 제공하지만, 이들을 약간씩 다르게 한다면 공통의 인터페이스를 만들고 둘이 이를 구현 (인터페이스 상속)
  - 공통된 연산이 없다면 완전 별개인 2개의 클래스를 만든다.
  - 만약 두 개체가 하는 일에 추가적으로 무언가를 더 한다면 구현 상속을 사용.

<br>

### 4. ISP (인터페이스 분리 원칙: Interface Segregation Principle)

> 한 클래스는 자신이 사용하지 않는 인터페이스를 구현하지 말아야 한다.
>
> 어떤 클래스가 다른 클래스에 종속될 때에는 가능한 최소한의 인터페이스만을 사용해야 한다.

- 일반적인 한개의 인터페이스보다 구체적인 여러가지의 인터페이스를 구현하는 원칙
- SRP가 클래스의 단일책임을 강조한다면 ISP는 인터페이스의 단일 책임을 강조
- SRP의 목표는 클래스 분리를 통하여 이루어지고 ISP는 인터페이스 분리를 통하여 이루어짐
- 예를들어 한 부모클래스가 여러 자식클래스를 만들어낼때 자식클래스에서 부모클래스에서 사용하는 메소드를 사용하지 않는 경우에는 그 해당 메소드 부분만 따로 인터페이스로 빼서 붙히는 방식으로 해야한다.

<br>

### 5. DIP (의존 역전 원칙: Dependency Inversion Principle)

> 하위 레벨 모듈의 변경이 상위 레벨 모듈의 변경을 요구하는 위계관계를 끊는 의미의 역전
>
> 실제 사용 관계는 바뀌지 않으며, 추상을 매개로 메시지를 주고 받음으로써 관계를 최대한 느슨하게 만드는 원칙

- DIP는 각각의 Class 또는 모듈 간의 의존성을 끊고 상위 레벨에서 정의한 추상을 하위레벨 모듈이 구현하게 하는 원칙으로 외부에서 의존성을 주입받아 Low Coupling을 만들게 하는게 목표
- 하위 수준의 정보는 인터페이스를 만들어서 그냥 해당 인터페이스 함수를 부르기만하면되지 일일이 바꿔줄필요가 없다는거임

<br>

#### [참고]

> - https://www.nextree.co.kr/p6960/
> - https://velog.io/@lsb156/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EA%B0%9C%EB%B0%9C-5%EB%8C%80-%EC%9B%90%EC%B9%99-SOLID
> - https://lazineer.tistory.com/93