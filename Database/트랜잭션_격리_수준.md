# 트랜잭션 격리 수준

### 동시성 제어(Currency Control)

- 다중 사용자 환경에서 둘 이상의 트랜잭션이 동시에 수행될 때, 일관성을 해치지 않도록 트랜잭션의 데이터 접근을 제어해야함.
- 다중 사용자 환경을 지원하는 DBMS의 경우, 반드시 지원해야 하는 기능
- 트랜잭션의 직렬화 수행 보장

#### 동시성 제어의 목적

- 트랜잭션의 직렬성 보장
- 공유도 최대, 응답 시간 최소, 시스템 활동의 최대 보장
- 데이터의 무결성 및 일관성 보장

<br>

#### 동시성 제어를 하지 않은 경우 문제점

**갱신 손실(Lost Update)**

- 하나의 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어씀으로써 갱신이 무효화가 되는 것
- 두 개 이상 트랜잭션이 한 개의 데이터를 동시에 갱신(update)할 때 발생

**현행파악오류(Dirty Read)**

- 읽기 작업을 하는 트랜잭션 1이 쓰기 작업을 하는 트랜잭션 2가 작업한 중간 데이터를 읽기 때문에 발생
- 작업중인 트랜잭션 2가 작업을 Rollback한 경우 트랜잭션 1은 무효가 된 데이터를 읽게 되고 잘못된 결과 도출

**모순성(Inconsistency)**

- 다른 트랜잭션들이 해당 항목 값을 갱신하는 동안 한 트랜잭션이 두 개의 항목 값 중 어떤 것은 갱신되기 전의 값을 읽고 다른 것은 갱신된 후의 값을 읽게 되어 데이터의 불일치가 발생하는 상황

**연쇄 복귀(Cascading Rollback)**

- 두 트랜잭션이 동일한 데이터 내용을 접근할 때 발생
- 한 트랜잭션이 데이터를 갱신한 다음 실패하여 Rollback 연산을 수행하는 과정에서 갱신과 Rollback 연산을 실행하고 있는 사이에 해당 데이터를 읽어서 사용할 때 발생할 수 있는 문제

<br>

#### 동시성 제어 기법의 종류

**락킹(locking)**

- 트랜잭션이 데이터에 잠금(lock)을 설정하면 다른 트랜잭션은 해당 데이터에 대해 잠금이 해제(unlock)될 때까지 접근/수정/삭제가 불가하다.
- 트랜잭션이 사용하는 자원에 대하여 상호 배제(Mutual Exclusive) 기능을 제공하는 기법

**타임스탬프(timestamp)**

- 시스템에서 생성하는 고유 번호인 타임스탬프를 트랜잭션에 부여함으로써 트랜잭션간의 접근 순서를 미리 정한다.

**적합성(validation) 검증**

- 먼저 트랜잭션을 수행하고 트랜잭션을 종료할 때 적합성을 검증하여 데이터베이스에 최종 반영한다.

<br>

### 트랜잭션 격리 수준(Isolation Level)

동시에 여러 트랜잭션이 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회한 데이터를 볼 수 있도록 허용 여부를 결정하는 것. 무조건적인 Locking 으로 동시에 수행되는 많은 트랜잭션들을 순서대로 처리할 시에 DB 성능은 떨어지게 되기 때문에, ACID를 유지하면서도 효율적인 Locking 방법을 모색하기 위해 격리 수준을 이해할 필요성이 있다.

#### [0단계] READ UNCOMMITED

각 트랜잭션의 변경 내용이 commit / rollback 여부에 상관없이 다른 트랜잭션에서 값을 읽을 수 있음

- 정합성에 문제가 많은 격리 수준이기 때문에 사용하지 않는 것을 권장함

#### [1단계] READ COMMITED

커밋된 데이터만 읽는 격리 수준

- 대부분의 RDB에서 기본적으로 사용되고 있는 격리 수준
- Dirty Read 현상 발생 x
- 실제 테이블 값을 가져오는 것이 아니라, Undo 영역의 백업된 레코드에서 값을 가져온다.
- 하나의 트랜잭션에서 똑같은 SELECT 쿼리를 실행하였을 때 항상 같은 결과를 가져와야하는 REPEATABLE READ의 정합성에서 어긋난다.

#### [2단계] REPEATABLE READ

데이터 조회시 항상 동일한 데이터 응답을 보장하는 고립 수준

- Undo 공간에 백업해두고 실제 레코드 값을 변경
- 백업된 데이터는 불필요하다고 판단하는 시점에서 주기적으로 삭제
- Undo에 백업된 레코드가 많아지면, 서버의 처리 성능이 떨어질 수 있다.
- **UPDATE** 한 데이터에 대해서는 정합성을 보장하지만, **INSERT/DELETE** 는 보장되지 않는다.
- 하나의 트랜잭션이 데이터를 읽고 다른 트랜잭션이 데이터를 쓰고 트랜잭션이 다시 한번 데이터를 읽을 때 생기는 문제로 읽기 작업을 다시 한 번 반복할 경우 이전에 없던 데이터가 나타나는 Phantom Read 문제가 발생함.

#### [3단계] SERIALIZABLE

모든 작업을 하나의 트랜잭션에서 처리하는 것과 같은 높은 고립 수준

- 가장 단순한 격리 수준이지만 가장 엄격한 격리 수준
- 성능 측면에서는 동시 처리 성능이 가장 낮음

<Br>

#### [참고]

> - https://chrisjune-13837.medium.com/db-transaction-isolation-level-f21b6d1e64eb
> - https://mangkyu.tistory.com/30
> - https://jokerkwu.tistory.com/125
> - https://feco.tistory.com/45
> - https://private-space.tistory.com/97

