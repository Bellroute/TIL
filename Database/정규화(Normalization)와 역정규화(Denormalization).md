# 정규화(Normalization)와 역정규화(Denormalization)

### 정규화(Normalization)란?

> 관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스 (위키백과)

</br>

### 정규화의 필요성

- 불필요한 데이터를 제거, 데이터의 중복을 최소화 하기 위해서
- 데이터베이스 구조 확장 시 재디자인을 최소화
- 다양한 관점에서의 query를 지원하기 위해서
- 무결성 제약조건의 시행을 간단하게 하기 위해서
- 각종 이상 현상(Anomaly)을 방지하기 위해서, 테이블의 구성을 논리적이고 직관적으로 한다.

</br>

데이터베이스를 잘못 설계하면 불필요한 데이터 중복으로 인한 공간낭비를 넘어 부작용을 초래할 수 있다. 이러한 부작용에는 삽입이상, 갱신이상, 삭제이상이 있다.

**삽입 이상 (Insertion Anomaly)**

> 새 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야 하는 문제
>
> Ex) 학생들의 강의 정보와 성적이 들어간 테이블에 아직 수업을 하나도 수강하지 않은 학생을 넣으려고 할 때 기본키로 학번과 과목코드를 지정해두었다면, 기본키로 쓰이는 컬럼은 NULL이 될 수 없으므로 테이블에 추가할 수 없게 된다.

**갱신 이상 (Update Anomaly)**

> 중복 튜플 중 일부만 변경하여 데이터가 불일치하게 되는 모순의 문제
>
> Ex) 특정 학생의 학과를 변경하려고 한다면 그 학생에 관한 모든 튜플의 학과를 변경해줘야 한다. (학생 관련 튜플이 N개가 존재한다면 N번 수정을 해야함)

**삭제 이상 (Deletion Anomaly)**

> 튜플을 삭제하면 꼭 필요한 데이터까지 함께 삭제되는 데이터 손실의 문제
>
> Ex) 1개의 과목만 수강하고 있는 학생이 있고, 그 학생이 해당 과목을 수강취소하게 되면 해당 학생에 대한 정보를 모두 날리게 된다.

</br>

정규화 된 정도를 정규형(Normal Form)으로 표현하는데, 정규형에는 1NF, 2NF, 3NF, BCNF, 4NF, 5NF, 6NF까지 존재한다. 높은 단계로 갈수록 중복이 적은 릴레이션으로 설계되지만 비공식적으로 3NF가 되었으면 정규화 되었다고 말한다.

</br>

### 제1정규형 (First Normal Form, 1NF)

> 1. 어떤 Relation에 속한 모든 Domain이 원자값(atomic value)만으로 되어 있다.
> 2. 모든 attribute에 반복되는 그룹(repeating group)이 나타나지 않는다.
> 3. 기본키를 사용하여 관련 데이터의 각 집합을 고유하게 식별할 수 있어야 한다.

[1번을 위반한 경우 - Tag 칼럼에 다수의 데이터가 들어가 있음 (원자성 x)]

| Id   | Title | Description  | Tag       |
| ---- | ----- | ------------ | --------- |
| 1    | MySQL | MySQL is ... | rdb, free |

[2번을 위반한 경우 - Tag 그룹이 반복되고 있음]

| Id   | Title | Description  | Tag1 | Tag2 |
| ---- | ----- | ------------ | ---- | ---- |
| 1    | MySQL | MySQL is ... | rdb  | free |

[정상적인 1NF]

| Id   | Title | Description  | Tag  |
| ---- | ----- | ------------ | ---- |
| 1    | MySQL | MySQL is ... | rdb  |
| 2    | MySQL | MySQL is ... | free |

(여전히 중복이 많아 보이지만 우선은 1NF를 만족하는 경우이다.)

</br>

### 제2정규형 (Second Normal Form, 2NF)

> - 테이블의 모든 컬럼이 **완전 함수적 종속**을 만족한다. (부분 함수적 종속을 제거하는 작업)

- **함수적 종속** : X(결정자)의 값에 따라 Y(종속자)값이 결정될 때 X -> Y로 표현하는데, 이를 Y는 X에 대해 함수적 종속이라고 한다. 예를 들어 학번을 알면 이름을 알 수 있는데, 이 경우 학번이 X가 되고 이름이 Y가 된다.

- 함수적 종속에서 X의 값이 여러 요소일 경우, 즉 {x1, x2} -> Y일 경우
  - x1과 x2가 Y의 값을 결정할 때 -> **완전 함수적 종속**
  - 둘 중 하나만 Y의 값을 결정할 때 -> **부분 함수적 종속**

</br>

| 이름   | 강의         | 학년 |
| ------ | ------------ | ---- |
| 마이크 | 데이터베이스 | 3    |
| 마이크 | 자료구조     | 3    |
| 린다   | 자료구조     | 2    |

이 테이블의 경우 이름과 강의에 의해 학년이 결정되고 있어 보이지만({이름, 강의} -> 학년),
이름에 의해 학년이 결정되기도 한다({이름} - > 학년).

다시 말해서 부분 함수적 종속이 존재하기 때문에 이를 제거해야만 2NF를 만족한다고 할 수 있다.

**[이름-강의 릴레이션]**

| 이름   | 강의         |
| ------ | ------------ |
| 마이크 | 데이터베이스 |
| 마이크 | 자료구조     |
| 린다   | 자료구조     |

**[이름-학년 릴레이션]**

| 이름   | 학년 |
| ------ | ---- |
| 마이크 | 3    |
| 린다   | 2    |

</br>

### 제3정규형 (Third Normal Form, 3NF)

> 1. Relation이 2NF를 만족한다.
> 2. 기본키(primary key)가 아닌 속성(Attribute)들은 기본키에만 의존해야 한다. (**이행 함수 종속성(Transitive Dependency)**을 제거하는 작업)

**이행 함수 종속성(Transitive Dependency)** : 삼단논법 같은 관계를 가진 함수 종속. X -> Y이고 Y -> Z 이면 X -> Z가 성립한다. 이를 Z가 X에 이행적으로 함수 종속되었다고 한다.

| 대회명               | 년도 | 우승자 | 생년월일   |
| -------------------- | ---- | ------ | ---------- |
| 핀테크 해커톤        | 2019 | 김xx   | 1995.04.09 |
| 대학생 알고리즘 대회 | 2019 | 박oo   | 1994.10.03 |
| 핀테크 해커톤        | 2020 | 박oo   | 1994.10.03 |
| 빅데이터 공모전      | 2020 | 심ㅁㅁ | 1997.11.11 |

위 테이블에 의하면 {대회명, 년도}에 의해 우승자가 결정되고, {우승자}에 의해 생년월일이 결정된다. `{대회명, 년도} -> {우승자} -> 생년월일` 이 되어 결국 `{대회명, 년도} -> 생년월일` 이라는 **이행 함수 종속성**을 띄게 된다. (일반적으로 생각해봐도 대회명과 년도에 의해 우승자의 생년월일이 결정된다는 것은 말이 안된다.)

이러한 이행 함수 종속성은 다음과 같이 테이블을 분리함으로써 제거하여 3NF를 만족시킬 수 있다.

**[대회 우승자 릴레이션]**

| 대회명               | 년도 | 우승자 |
| -------------------- | ---- | ------ |
| 핀테크 해커톤        | 2019 | 김xx   |
| 대학생 알고리즘 대회 | 2019 | 박oo   |
| 핀테크 해커톤        | 2020 | 박oo   |
| 빅데이터 공모전      | 2020 | 심ㅁㅁ |

**[우승자 생년월일 릴레이션]**

| 우승자 | 생년월일   |
| ------ | ---------- |
| 김xx   | 1995.04.09 |
| 박ㅇㅇ | 1994.10.03 |
| 심ㅁㅁ | 1997.11.11 |

</br>

#### BCNF(보이스-코드 정규형)

> 릴레이션에서 모든 결정자가 후보키가 되도록 하는 과정

#### 제 4정규형(4NF)

> 다치 종속 관계가 성립되는 경우 분해하는 과정
>
> **※다치 종속(MVD, Multival Dependency):** 두 속성이 1:다 대응이 되는 경우

#### 제 5정규형(5NF)

> 조인 종속(Join Dependency)이 후보키를 통해서만 성립이 되도록 하는 정규형

</br>

</br>

### 역정규화(Denormalization)란?

> 정규화된 릴레이션을 다시 통합하거나 분할하여 구조를 재조정하는 과정

정규화를 한다는 것은 중 하나의 릴레이션을 여러 개의 릴레이션으로 분해한다는 것을 의미한다. 따라서 원하는 데이터를 얻기 위해서는 다수의 릴레이션을 참조해야한다. 이는 데이터베이스에 저장된 자료를 검색하는 시간을 증가시키며 성능 저하의 결과를 초래할 수 있다. 때문에 데이터베이스의 물리적 설계 과정에서 성능을 향상시키기 위해서는 역정규화의 과정이 필요하다.</br>

### 역정규화의 종류

#### 1) 릴레이션 역정규화

> 두 릴레이션을 합하거나 하나의 릴레이션을 분할하는 방법

- **릴레이션 병합** : 두 릴레이션 간의 잦은 참조로 성능이 저하될 경우 이 문제점을 해결하기 위해 병합
- **릴레이션 분할** : 자주 사용하는 속성이나 튜플을 분해하여 성능을 향상 시키는 방법 (릴레이션의 데이터를 검색할 때는 목록을 순차적으로 조회함. 이 때 자주 사용하지 않는 속성이나 튜플이 있다면 검색이 느려지게 됨)
  - `수직 분할` - 자주 사용하는 `속성` 과 그렇지 않은 `속성` 을 분할
  - `수평 분할` - 자주 사용하는 `튜플` 과 그렇지 않은 `튜플` 을 분할

#### 2) 속성 역정규화

> 검색 성능을 향상시키기 위해 속성을 추가하거나 필요한 속성을 만드는 것

- **속성 추가** : 자주 사용하는 외래키 속성을 추가
- **파생 속성 추가** : 현재 릴레이션에 없는 속성이지만 작업 효율을 위해 새로운 속성을 추가함

</br>

#### [출처]

- [데이터베이스 정규화 개념 설명 및 예제](https://wkdtjsgur100.github.io/database-normalization/)

- [데이터베이스 정규화 - 이상현상 & 함수적 종속성](https://yaboong.github.io/database/2018/03/09/database-anomaly-and-functional-dependency/)

- [데이터베이스 정규화 - 1NF, 2NF, 3NF](https://yaboong.github.io/database/2018/03/09/database-normalization-1/)

- [정규화(Normaliztion)](https://ehpub.co.kr/tag/%EC%9D%B4%ED%96%89%EC%A0%81-%EC%A2%85%EC%86%8D-%EA%B4%80%EA%B3%84/)

- [[DB이론]정규화(Normaliztion)](https://victorydntmd.tistory.com/132)

- [데이터베이스의 정규화와 역정규화는 무엇이고 왜 필요한지 알아보자.](https://m.blog.naver.com/PostView.nhn?blogId=nog1922&logNo=221315065897&proxyReferer=https:%2F%2Fwww.google.com%2F)

- [데이터베이스 정규화(Normalization), 역정규화(DeNormalization)](https://dodo000.tistory.com/21)