# 쿠키(Cookie)와 세션(Session)

### 0. 쿠키와 세션을 사용하는 이유

쿠키와 세션을 알아보기에 앞서 이들을 사용하는 이유를 먼저 언급한 것은 HTTP의 특성과 연관이 있기 때문이다. HTTP의 여러 특성 중 Connectionless와 Stateless에 주목하자.

**Connectionless(비 연결지향)**

- HTTP에서는 클라이언트에서 서버에 요청을 보내면 서버는 클라이언트에서 응답을 하고 접속을 끊는 처리 방식을 갖는다.
- (HTTP 1.1 버전에서는 connection 헤더에 keep-alive를 설정하면 커넥션을 유지하여 연결 지연을 줄이는 노력을 기울였다.)

**Stateless(상태정보 유지 안함)**

- HTTP 통신은 요청을 응답하고 접속을 끊기 때문에 클라이언트의 상태 정보를 알 수 없다.



즉, HTTP는 요청-응답을 하고 나면 연결을 끊고 클라이언트의 상태 정보를 저장하지 않기 때문에,  동일한 클라이언트가 동일한 요청을 보낸다하더라도 서버는 매번 새로운 요청으로 받아들여 응답을 수행한다.



단순하다는 강점이 있지만, 실제로는 상태를 유지하는 것이 필요한 경우가 많다.

- 매번 페이지를 이동할 때마다 로그인을 다시해야 한다.
- 상품을 선택했는데 구매 페이지에서 선택한 상품의 정보가 사라진다.
- ...



따라서, 쿠키와 세션은 stateless한 HTTP를 stateful하게 다루기 위해 사용하는 것이다.



### 1. 쿠키(Cookie)

> 클라이언트 로컬에 저장되는 Key-Value 쌍의 작은 데이터 파일
>
> 사용자가 어떠한 웹 사이트를 방문할 경우, 그 사이트가 사용하고 있는 서버에서 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일로, HTTP에서 클라이언트의 상태 정보를 클라이언트의 PC에 저장하였다가 필요시 정보를 참좆하거나 재사용 가능하다.

**쿠키의 구성 요소**

- 이름 : 각각의 쿠키를 구별하는 데 사용되는 이름
- 값 : 쿠키의 이름과 관련된 값
- 유효시간 : 쿠키의 유지시간
- 도메인 : 쿠키를 전송할 도메인
- 경로 : 쿠키를 전송할 요청 경로
- Secure 속성 : HTTPS 프로토콜로 암호화된 요청일 경우에만 쿠키 허용
- HttpOnly 속성 : 자바스크립트의 `Document.cookie` API를 이용해 쿠키에 접근하는 것을 방지.  인증된 정보를 자바스크립트를 통해 탈취하는 Cross-site 스크립팅(XXS) 공격을 막는데 도움

**쿠키 특징**

- 클라이언트에 총 300개의 쿠키를 저장할 수 있다.

- 하나의 도메인 당 20개의 쿠키를 가질 수 있다

- 하나의 쿠키는 4KB(=4096byte)까지 저장 가능하다.

**쿠키의 동작 순서**

1. 클라이언트가 페이지를 요청한다. (사용자가 웹사이트 접근)
2. 웹 서버는 쿠키를 생성한다. (서버 애플리케이션 단에서 생성해서 응답 헤더에 추가해야함)
3. 생성한 쿠키에 정보를 담아 HTTP 화면을 돌려줄 때,
   같이 클라이언트에게 돌려준다.
4. 넘겨 받은 쿠키는 클라이언트가 가지고 있다가(로컬 PC에 저장)
   다시 서버에 요청할 때 요청과 함께 쿠키를 전송한다.
5. 동일 사이트 재방문시 클라이언트의 PC에 해당 쿠키가 있는 경우,
   요청 페이지와 함께 쿠키를 전송한다.

**사용 예시**

1. 방문했던 사이트에 다시 방문 하였을 때 아이디와 비밀번호 자동 입력
2. 팝업창을 통해 "오늘 이 창을 다시 보지 않기" 체크



### 2. 세션(Session)

> 브라우저가 종료되기 전까지 클라이언트의 요청을 유지하게 해주는 기술
>
> 일정 시간동안(웹 브라우저를 통해 웹 서버에 접속한 시점으로부터 웹 브라우저를 종료하여 연결을 끝내는 시점)동안 같은 사용자로부터 들어오는 요구를 하나의 상태로 보고, 그 상태를 일정하게 유지시키는 기술이다.

**세션 특징**

- 웹 서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장한다.

- 웹 서버의 저장되는 쿠키(=세션 쿠키)

- 브라우저를 닫거나, 서버에서 세션을 삭제했을ㅇ때만 삭제가 되므로,
  쿠키보다 비교적 보안이 좋다.

- 저장 데이터에 제한이 없다.(서버 용량이 허용하는 한...)

- 각 클라이언트 고유 Session ID를 부여한다.
  Session ID로 클라이언트를 구분하여 각 클라이언트 요구에 맞는 서비스 제공

**세션의 동작 순서**

1. 클라이언트가 페이지를 요청한다. (사용자가 웹사이트 접근)
2. 서버는 접근한 클라이언트의 Request-Header 필드인 Cookie를 확인하여,
   클라이언트가 해당 session-id를 보냈는지 확인한다.
3. session-id가 존재하지 않는다면,
   서버는 session-id를 생성해 클라이언트에게 돌려준다.
4. 서버에서 클라이언트로 돌려준 session-id를 쿠키를 사용해 서버에 저장한다.
   쿠키 이름 : JSESSIONID
5. 클라이언트는 재접속 시,
   이 쿠키(JSESSIONID)를 이용하여 session-id 값을 서버에 전달

**사용 예시**

- 화면이 이동해도 로그인이 풀리지 않고 로그아웃하기 전까지 유지



### 3. 쿠키 vs 세션

**1.저장위치**

- 쿠키 : 클라이언트에 파일로 저장
- 세션 : 서버에 저장

**2.보안**

- 쿠키 : 클라이언트 로컬에 저장되기 떄문에 변질되거나 request에서 스니핑당할 우려가 있어서 보안 취약
- 세션 : 쿠키를 이용해서 세션id만 저장하고 그것으로 구분해서 서버에서 처리하기 떄문에 비교적 안전 (보안 면에서 쿠키보다 우수)

**3.라이프 사이클**

- 쿠키 : 만료시간은 있지만 파일로 저장되기 떄문에 브라우저를 종료해도 계속해서 정보가 남아 있을수 있음. 만료기간을 넉넉히 잡아두면 쿠키삭제 할 때까지 유지될수도 있음.
- 세션 : 만료기간을 정할수는 있지만 브라우저가 종료되면 그에 상관없이 삭제

**4.속도**

- 쿠키 : 쿠키에 정보가 있기 떄문에 서버에 요청시 속도가 빠르다.
- 세션 : 정보가 서버에 있기 떄문에 처리가 요구되어 비교적으로 느림



세션이 쿠키에 비해 사용성이나 보안 측면에서 나아보이는데, 굳이 쿠키를 함께 사용하는 이유가 뭘까?

답은 세션은 서버 자원을 사용한다는 점에 있다. 세션은 서버에 저장되기 때문에 사용자가 늘어날수록 상태 유지를 위해 소모되는 자원이 상당하다. 때문에 서버의 부하를 줄이고, 응답 속도를 높이기 위해서는 쿠키와 세션의 적절한 병행이 필요하다.4



### 4. 웹 스토리지(Web Storage)

> 클라이언트에 데이터를 저장할 수 있도록 HTML5부터 새롭게 지원하는 저장소

**특징**

- 키(Key)와 값(Value)의 쌍 형태로 데이터를 저장한다.
- 쿠키와 달리, 서버에 전송되지 않으므로 서버에 부담이 가지 않는다.
- 기능 자체는 쿠키와 유사하지만, 쿠키는 약 4KB까지 밖에 저장 공간을 이용하지 못하는 반면에 웹 스토리지는 약 5MB까지 저장 공간을 이용할 수 있다.
- 쿠키와 달리, 필요한 경우에만 꺼내 쓰는 것이므로 자동 전송의 위험성이 없다. 다른 도메인에서 요청하는 경우에는, 꺼내 쓰고 싶어도 도메인 단위로 접근이 제한되는 특성 덕분에 값을 꺼내 쓸 수 없다. (CSRF 안전)
- 쿠키와 달리, 대략 5MB까지의 데이터를 저장할 수 있으며 유효 기간이 존재하지 않는다.
- HTML5를 지원하지 않는 브라우저에서는 사용할 수 없다.
- 종류로는 로컬 스토리지(Local Storage)와 세션 스토리지(Session Storage)가 있다.

**로컬 스토리지(Local Storage)**

- window.localStorage 객체
- **브라우저를 종료해도 유지되는 데이터, 명시적으로 지우지 않는 한 영구적으로 저장**
- 도메인별로 생성, 다른 도메인의 로컬 스토리지에는 접근 불가
- 서로 다른 브라우저 탭 - 동일한 도메인 => 동일한 로컬 스토리지 사용
- 지속적으로 필요한 정보를 저장하기 좋음 (ex. 자동 로그인)

**세션 스토리지(Session Storage)**

- window.sessionStorage 객체

- 탭/윈도우 단위로 세션 스토리지가 생성된다. 탭/윈도우를 닫으면 데이터 삭제됨. (window 객체와 동일한 유효 범위 및 라이프 사이클을 가짐)
- 다른 탭/윈도우 - 같은 도메인 => 다른 세션 스토리지 생성
- 서로 다른 세션 스토리지 간 영향을 주지 않으며 독립적으로 동작
- 잠시 동안 필요한 정보를 저장하기 좋음 (ex. 입력 폼 저장, 일회성 로그인 등)



### 4. 세션 기반 인증의 한계

쿠키-세션(엄밀히 따지자면 세션)을 통해 HTTP의 상태를 유지하여 서비스 이용자를 인증하는 방식을 **세션 기반 인증** 이라고 한다. 이러한 세션 기반 인증 방식은 서비스의 규모가 커질수록 다음과 문제점을 보이기 시작한다.

- **세션으로 인한 서버 부하**
  - 세션으로 로그인 중인 사용자를 관리하는 경우, 사용자가 늘어날수록 서버의 RAM에 부하가 걸린다.
  - 이를 피하기 위해 데이터베이스에 저장을 하기도 하는데, 이 방식 역시 데이터베이스에 무리를 준다. + 속도도 느리다.
- **확장성**
  - 사용자가 증가함에 따라 더 많은 트래픽을 처리하기 위해 여러 프로세스를 돌리거나 서버 확장이 필요해질 수 있따.
  - 하지만, 세션을 사용한다면 세션을 분산시키는 시스템을 설계해야하지만 과정이 쉽지 않다.
  - 중앙 세션 관리 시스템을 설계했다하더라도, 이 시스템이 장애가 일어나면 시스템 전체에 문제가 생길 수 있음.
- **CORS(Cross-Origin Resource Sharing)**
  - 웹 애플리케이션에서 세션을 관리하기 위해 쿠키를 사용한다.
  - 하지만 쿠키는 단일 도메인 및 서브 도메인에서만 작동하도록 설계되어 있음.
  - 멀티 디바이스 환경에서 관리가 어렵다.

(HTTP REST 아키텍처 스타일 윈칙 중 무상태성이라는 원칙을 위반하기도 한다.)



이러한 세션 기반 인증의 한계를 개선하기 위해 등장한 방법이 **토큰 기반 인증**이다.

토큰 기반 인증 방식은 인증받은 사용자들에게 토큰을 발급하고, 서버에 요청할 때 헤더에 토큰을 함께 보내도록 하여 유효성을 검사하는 방식으로, 사용자의 인증 정보를 서버나 세션에 유지하지 않아도 되는 Stateless한 구조를 갖는다.

(토큰 기반 인증에 대한 내용은 따로 다루도록 한다.)



#### [참고]

> - https://interconnection.tistory.com/74
> - https://hahahoho5915.tistory.com/32
> - https://it-eldorado.tistory.com/90
> - https://chrisjune-13837.medium.com/web-%EC%BF%A0%ED%82%A4-%EC%84%B8%EC%85%98%EC%9D%B4%EB%9E%80-aa6bcb327582
> - https://velog.io/@stay136/%EA%B8%B0%EC%88%A0-%EC%BF%A0%ED%82%A4%EC%99%80-%EC%84%B8%EC%85%98%EC%9D%98-%EC%B0%A8%EC%9D%B4
> - https://untitledtblog.tistory.com/47
> - https://velog.io/@hellozin/%EC%BF%A0%ED%82%A4-%EC%84%B8%EC%85%98-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%9B%B9-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80
> - https://mangkyu.tistory.com/55





### 생각해 볼만한 질문

- 쿠키와 세션의 공통점과 차이점
- 쿠키와 캐시의 차이점
- 쿠키와 웹 스토리지를 어떻게 구분해서 사용해야할까? (어떠한 경우에 쿠키를 쓰고, 어떤 경우에 웹 스토리지를 쓸지)