# ORM(Object Relational Mapping)

> **객체 관계 매핑**(Object-relational mapping; ORM)은 데이터베이스와 객체 지향 프로그래밍 언어 간의 호환되지 않는 데이터를 변환하는 프로그래밍 기법이다.  -위키피디아-

- 객체지향 프로그래밍은 클래스를 사용하고, 관계형 데이터베이스는 테이블을 사용하기 때문에 객체 모델과 관계형 모델간에 불일치가 존재할 수 밖에 없음
- ORM은 객체 간의 관계를 바탕으로 SQL을 자동으로 생성하여 `불일치`를 해결해줌
- 객체를 통해 간접적으로 데이터베이스의 데이터를 다룬다고 할 수 있음

<br>

### ORM의 장단점

#### 장점

- **객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 더 집중할 수 있게 도와준다.**
  - ORM을 이용하면 SQL이 아닌 직관적인 코드, 메서드로 데이터를 조작 => 객체지향적인 프로그래밍 가능
  - SQL 문을 사용하면서 같이 필요한 선언문, 할당, 종료 같은 부수적인 코드가 사라지거나 줄어듦
  - 객체에 대한 코드를 별도로 작성하여 코드의 가독성을 높일 수 있다.
  - SQL의 절차적/순차적 접근 x. 객체지향적 접근만 고려하면 되기때문에 생산성이 증가
- **재사용 및 유지보수의 편리성이 증가한다.**
  - ORM은 기존 객체와 독립적으로 작성되어있고, 객체로 작성되었기 때문에 재활용 가능
- **DBMS에 대한 종속성이 줄어든다.**
  - SQL 자동 생성, 객체의 자료형 타입을 사용하기 때문에 RDBMS의 데이터 구조와 객체 간의 차이를 좁힘
  - 객체에만 집중할 수 있기 때문에 DBMS를 교체하는 큰 작업에도 리스크가 적고 드는 시간도 줄어든다.

#### 단점

- 완벽한 ORM으로만 서비스를 구현하기 어려움
  - 프로젝트의 복잡성이 커질 수록 난이도도 올라감. 
  - 부족한 설계로 잘못 구현되었을 경우 속도 저하 및 일관성을 무너뜨리는 문제점 발생.
  - 일부 자주 사용되는 대형 SQL문은 속도를 위해 별도의 튜닝이 필요 -> 결국 SQL문을 써야함.
- 프로시저가 많은 시스템에선 ORM의 객체 지향적인 장점을 활용하기 어려움.
  - `프로시저(procedure)` - 쿼리문을 마치 하나의 메서드 형식으로 만들고 어떠한 동작을 일괄적으로 처리하는 용도로 사용. 조인, 조건 등으로 길어진 하나의 쿼리문 대신, 여러 개의 쿼리를 프로시저에 저장하여 프로시저를 호출하는 방식으로 사용.

<br>

### 객체-관계 간의 패러다임 불일치

#### 세분성(Granularity)

- 경우에 따라서 데이터베이스에 있는 테이블 수보다 더 많은 클래스를 가진 모델이 생길 수 있다.

- Ex) `회원 세부사항` - 회원 세부사항 정보를 가진 Member라는 클래스와 재사용성과 유지보수성을 위해 Address라는 클래스를 만들 수 있지만, 데이터베이스에서는 회원 정보를 Member라는 하나의 테이블로 저장시킬 수 있음. 

#### 상속성(Inheritance)

- RDBMS는 객체지향 프로그래밍 언어의 특징인 상속 개념이 없다.

#### 일치(Identity)

- RDBMS는 기본키(primary key)를 이용하여 동일성을 정의한다. 
- 그러나 자바는 [객체 식별(`a==b`)과 객체 동일성(`a.equals(b)`)을 모두 정의한다.

#### 연관성(Associations)

- 객체지향 언어는 방향성이 있는 객체의 참조(reference)를 사용하여 연관성을 나타내지만 
- RDBMS는 방향성이 없는 외래키(foreign key)를 이용해서 나타낸다.

#### 탐색(Navigation)

- 자바와 RDBMS에서 객체를 접근하는 방법이 근본적으로 다르다. 
- 자바는 그래프형태로 하나의 연결에서 다른 연결로 이동하며 탐색한다. 
- 그러나 RDBMS에서는 일반적으로 SQL문을 최소화하고 `JOIN`을 통해 여러 엔티티를 로드하고 원하는 대상 엔티티를 선택하는 방식으로 탐색한다.



### JPA vs Hibernate vs Spring Data JPA

![JPA, Hibernate, Spring Data JPA의 전반적인 그림](https://suhwan.dev/images/jpa_hibernate_repository/overall_design.png)

#### JPA(Java Persistence API)

자바 ORM 기술에 대한 표준 인터페이스.

- JPA는 기술 명세이다.
- 말 그대로 인터페이스임. 구현이 없음.
  - JPA를 정의한 `javax.persistence` 패키지의 대부분은 `interface`, `enum`, `Exception`, 그리고 각종 `Annotation`으로 이루어져 있음

#### Hibernate

Hibernate는 JPA라는 명세의 구현체이다.

- JPA에서 명세된 인터페이스를 직접 구현한 라이브러리
- JPA와 Hibernate는 마치 자바의 interface와 해당 interface를 구현한 class와 같은 관계
- 즉, JPA를 사용하기 위해서 반드시 Hibernate를 사용할 필요가 없음. 다른 것을 사용하거나 직접 구현도 가능. 단지 Hibernate가 굉장히 성숙한 라이브러리일 뿐.

#### Spring Data JPA

Spring Data JPA는 Spring에서 JPA를 쓰기 편하게 만들어 놓은 모듈이다.

- JPA를 한 단계 추상화시킨 `Repository`라는 인터페이스를 제공 => 개발자가 JPA를 더 쉽고 편하게 사용 가능
- Spring으로 개발하면서 단 한번도 EntityManager를 직접 다뤄본 적이 없는 이유가 Spring Data JPA가 이를 잘 추상화 시켰기 때문. 모듈 내부적으로는 이미 사용하고 있음.

<br>

### +) JPA 영속성 컨텍스트

https://heowc.tistory.com/55

JPA의 영속성 컨텍스트는 서버 사이드와 데이터베이스 사이드 사이에서 엔티티를 저장하는 논리적인 영역이다. 데이터베이스에 데이터의 상태를 바로 반영하는 것이 아니라 영속성 컨텍스트에서 가지고 있다가 1차캐시, 더티체킹, 라이트비하인드 등의 기능으로 데이터베이스와 연결함으로 인한 리소스를 줄여줌으로써 효율적인 데이터 처리를 지원한다.

- *1차 캐시*: Session이라는 Persistence Context에 인스턴스가 저장된 상태를 의미
- *Dirty Checking* : 객체의 변경 사항을 계속해서 감지해 변경이 되었을 시에 자동으로 업데이트하는 기능
- *Write Behind* : 객체의 상태 변화를 데이터베이스에 최대한 늦게, 가장 필요한 시점에 적용하는 개념. 변경을 시도해도 원래 값과 비교했을 때 동일하면 데이터베이스에 반영하지 않음.

<br>

#### [참고]

- https://geonlee.tistory.com/207
- https://gmlwjd9405.github.io/2019/02/01/orm.html
- https://eun-jeong.tistory.com/31
- https://runcoding.tistory.com/31
- https://suhwan.dev/2019/02/24/jpa-vs-hibernate-vs-spring-data-jpa/

