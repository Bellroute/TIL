# IoC와 DI

### IoC(Inversion Of Control): 제어의 역전

"제어의 역전"이란 프로그램의 **제어 흐름 구조가 뒤바뀌는 것**. 말 그대로 메소드나 객체의 호출 작업 개발자가 결정하는 것이 아니라, 외부에서 결정되는 것을 의미한다.

**일반적인 프로그램의 흐름은**

- main() 메소드와 같이 프로그램이 시작되는 지점에서 다음에 사용할 오브젝트를 결정, 생성, 호출하는 식의 작업이 반복
- 각 오브젝트는 프로그램 흐름을 결정하거나 사용할 오브젝트를 구성하는 작업에 능동적으로 참여함
- 모든 오브젝트가 능동적으로 자신이 사용할 클래스를 결정하고, 언제 어떻게 만들지를 스스로 관장
- 모든 종류의 작업을 사용하는 쪽에서 제어하는 구조

**제어의 역전에서는 이런 제어 흐름의 개념을 거꾸로 뒤집는다.**

- 오브젝트가 자신이 사용할 오브젝트를 스스로 선택, 생성하지 않음.
- 자신도 어떻게 만들어지고 어디서 사용되는지를 알 수 없음
- 모든 제어 권한을 자신이 아닌 다른 대상에게 위임하기 때문
- 프로그램의 시작을 담당하는 엔트리 포인트(main() 메소드)를 제외하면 모든 오브젝트는 위임받은 제어 권한을 갖는 특별한 오브젝트에 의해 결정되고 만들어짐

<br>

#### 왜 IoC를 사용할까?

객체의 라이프사이클을 관리하는 부분과 비즈니스 로직을 담당하는 부분으로 관심을 분리하여 각자의 역할은 충실히 행하면서 변경, 확장에는 열려있는 유연한 코드를 작성할 수 있는 구조를 설계하기 위함.

- IoC는 Spring에서만 사용되는 개념이 아님. 작게는 객체 간에 디자인 패턴으로, 크게는 컨테이너, 프레임워크 역할에 적합한 구조이기 때문에 사용됨.
- 역할과 책임을 분리하여 변경에 유연한 코드 구조를 가져가기 위함(높은 응집도와 낮은 결합도) => OOP의 핵심(결국엔 재사용성을 위해)
- 컨테이너 차원에서는 엔터프라이즈 개발에 적합하게 수많은 객체 생명주기를 관리 하고 의존 관계를 설정해주고 그 외 많은 기능들을 제공하여 개발자는 비지니스 로직에 집중 할 수 있게 해주는 것이죠. **(스프링이 가지는 강점)**

<br>

#### 적용 사례

- **서블릿** - 서블릿에 대한 제어 권한을 가진 컨테이너가 적절한 시점에서 서블릿 클래스의 오브젝트를 만들고 그 안에 메소드를 호출
- **템플릿 메소드 패턴** - 서브클래스가 구현을 담당하지만 언제 어떻게 사용될지는 슈퍼클래스에서 결정. 제어권을 상위 템플릿 메소드에 넘기고 자신은 필요할 때 호출되어 사용되도록 함.
- **프레임워크** - 프레임워크는 라이브러리의 다른 이름이 아님. 프레임워크는 분명한 제어의 역전 개념이 적용됨

`서블릿(servlet)` - 서버에서 웹페이지 등을 동적으로 생성하거나 데이터 처리를 수행하기 위해 자바로 작성된 프로그램

`컨테이너(container)` - 인스턴스의 라이프사이클을 관리, 생성된 인스턴스들에게 추가적인 기능을 제공.

<br>

### DI(Dependency Injection): 의존관계 주입

"의존관계 주입"은 객체를 직접 생성하는 것이 아니라 외부에서 생성한 후 주입 시켜주는 방식이다.

**의존 관계**

- 두 개의 클래스 또는 모듈이 의존 관계에 있다고 말할 때는 항상 방향성을 부여해야 함. (누가 누구에게 의존하는 관계에 있다) 
- 의존한다는 건 의존 대상이 변하면 그것이 나머지 대상에게 영향을 미친다는 뜻
- A가 B에 의존하고 있다고 하면, B의 기능이 추가되거나 변경되거나 하면 그 영향이 A로 전달 된다.

<br>

**[DI가 적용되지 않은 경우]**

```java
public class Toy {
  private Battery b;
  
  public A() {
    b = new BatteryA();
  }
}
```

**[DI가 적용된 경우]**

```java
// 생성자 주입
public class Toy {
  private Battery b;
  
  public A(Battery b) {
    this.b = b;
  }
}
```

DI가 적용되지 않은 경우를 살펴 보면 Toy라는 객체에서 내부적으로 필요한 Battery라는 객체를 BatteryA라는 객체로 직접 결정해서 사용하고 있다. 향후 요구사항이 변경되어 BatteryA가 아닌 BatteryB를 사용하게 된다면 어떻게 될까? 변경되는 건 Battery인데 Toy라는 객체까지 수정해야하는 상황이 발생한다. SOLID원칙 중 OCP 원칙에 위반 된다.

반면, DI가 적용된 경우에는 Toy에서 사용될 Battery를 외부에서 결정된 객체를 주입받아 사용한다. 이렇게 되면 Battery가 A이든, B이든 간에 Toy를 수정하지 않고도 얼마든지 변경, 확장이 가능하다.

<br>

DI는 말 그대로 의존적인 객체를 직접 생성하거나 제어하는 것이 아니라, 특정 객체에 필요한 객체를 외부에서 결정해서 연결 시키는 것을 의미한다. 즉, 우리는 클래스의 기능을 추상적으로 묶어둔 인터페이스만 가져다 쓰면 되고, 실제 객체는 IoC로 인해 외부 컨테이너에서 생성된 객체를 주입 받아 사용하는 것이다. 덕분에 **모듈 간의 결합도는 낮아지고 유연성은 높아진다**는 장점을 갖는다.

`빈(Bean)` - 스프링 컨테이너에서 관리하는 객체를 의미하며 @Component가 붙은 객체가 이에 해당.

<br>

#### Spring Framework에서 의존성을 주입하는 3가지 방법

#### 1. 생성자 주입(Constructor Injection)

생성자에 의존성 주입을 받고자 하는 필드를 파라미터로 나열한다.

```java
@Component
public class Toy {
  private Battery b;
  
  // spring 4.3부터 @Autowired 생략 가능
  public A(Battery b) {
    this.b = b;
  }
}
```

#### 2. 수정자 주입(Setter Injection)

set Method에 @Autowired를 붙인다..

```java
@Component
public class Toy {
  private Battery b;

  @Autowired
  public void setBattery(Battery b) {
    this.b = b;
	}
}
```

#### 3. 필드 주입(Field Injection)

변수 선언부에 @Autowired를 붙인다.

```java
@Component
public class Toy {
  @Autowired
  private Battery b;
}
```

가장 권장되는 것은 **생성자 주입** 이다.

- 필수적으로 사용해야 하는 레퍼런스 없이는 인스턴스를 만들지 못하도록 강제함
- 순환 참조 의존성을 알아 차릴 수 있음
- 생성자에 많은 의존성이 추가될 경우 리팩토링 시점을 감지할 수 있음
- 의존성 주입 대상 필드를 final로 불변 객체 선언할 수 있음

<br>

#### [참고]

> - https://pks424.tistory.com/entry/IoC-DI%EB%9E%80
> - https://jobc.tistory.com/30
> - https://biggwang.github.io/2019/08/31/Spring/IoC,%20DI%EB%9E%80%20%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/
> - https://velog.io/@gillog/Spring-DIDependency-Injection
> - https://jobjava00.github.io/language/java/framework/spring/container/
> - https://leejisoo860911.tistory.com/2
> - https://baek.dev/post/21/
> - https://velog.io/@gillog/Spring-DIDependency-Injection-%EC%84%B8-%EA%B0%80%EC%A7%80-%EB%B0%A9%EB%B2%95

