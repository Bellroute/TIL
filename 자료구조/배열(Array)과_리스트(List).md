# 배열(Array) & 리스트(List)

### 배열(Array)

- 여러 데이터를 하나의 이름으로 그룹핑해서 관리하기 위한 자료구조
- index와 값의 쌍으로 구성되어 있음
- index는 값에 대한 유일무이한 식별자이다.
- 논리적 저장 순서와 물리적 저장 순서가 일치
- 연속된 메모리 공간으로 이루어져 있음.
- 정의와 동시에 길이를 지정하며 길이를 바꿀 수 없다.

#### 장점

- Random Access가 가능 => 인덱스 값만 알고 있다면 검색에 대한 시간복잡도는 `O(1)`
- 연속적이므로 메모리 관리가 편함.

#### 단점

- 크기가 고정되어 있기 때문에 특정 엘리먼트 삭제 시에도 해당 공간을 빈 공간으로 남겨 둠. => 메모리 낭비
- 배열의 크기를 미리 지정해주어야 한다.
- 배열의 크기를 변동할 수 없다.

</br>

### 리스트(List)

- 순서가 있는 엘리먼트의 모임으로 배열과는 다르게 빈 엘리먼트를 절대 허용하지 않음. (빈틈없는 데이터의 적재)
- 배열에서의 index는 유일무이한 식별자였다면, 리스트에서의 index는 데이터의 순서의 의미를 가짐.
- 빈 엘리먼트는 허용하지 않는다. (java에서는 허용하는 경우도 있음)
- 불연속적으로 메모리 공간을 차지.
- 포인터를 통한 접근
- spatical locality가 보장되지 않아서 cash hit(CPU가 참조하고자 하는 메모리가 캐시에 존재하고 있는 경우)가 어려움
  - locality는 기억 장치 내의 정보를 균일하게 접근하는 것이 아닌 어느 한 순간에 특정 부분을 집중적으로 참조하는 특성. 
  - 가장 최근 영역(temporal locality)에, 가장 접근하기 가까운 영역(spatical locality)에 데이터를 저장하는 것이 CPU가 메모리로부터 데이터를 가져오는데 훨씬 효과적이라는 것
  - 리스트는 연속된 메모리 공간에 할당되는 배열과 다르게 포인터를 통해 불연속적으로 메모리 공간을 차지하기 때문에 spatical locality가 보장되지 않음.

#### 장점

- 포인터를 통하여 다음 데이터의 위치를 가르켜고 있어 삽입 삭제의 용이.
- 동적이므로 크기가 정해져 있지 않다.
- 메모리의 재사용 편리
- 불연속적이므로 메모리 관리의 편리

#### 단점

- 검색 성능이 좋지 않다.
- 포인터를 통해 다음 데이터를 가르키므로 추가적인 메모리 공간 발생.

</Br>

### Java List Collection

![img](https://t1.daumcdn.net/cfile/tistory/2614AF3655269C1129)

List는 Collection 인터페이스를 확장한 자료형으로 동일한 데이터의 중복 입력이 가능하며 순차적이고 다량의 데이터를 입력할 때 주로 사용함.

#### ArrayList

- 인덱스로 객체를 관리한다는 점에서 일반 배열과 동일. 하지만, 크기를 동적으로 늘릴 수 있다는 점에서 차이가 있음.

- ArrayList는 내부에서 처음 설정한 저장 용량(capacity)가 있음. 설정한 저장 용량 크기를 넘어서 더 많은 객체가 들어오게 되면, 배열의 크기를 1.5배로 증가시킴

- 인덱스를 가지고 있어 **데이터 검색에 적합**하고 속도가 빠름 `O(1)`

- 데이터의 삽입, 삭제 시 해당 데이터를 제외한 모든 데이터를 임시 배열을 생성해 복사하므로 **삽입, 삭제가 빈번한 경우 속도가 느리며 부적합** `O(n)`

  ![img](https://media.vlpt.us/images/adam2/post/448cdf66-1186-469d-bcb8-868c8897c49f/image.png)

  ![img](https://media.vlpt.us/images/adam2/post/fff2cfde-fc6b-4423-bbe3-2e1109c09968/image.png)

- **접근 속도** : 인덱스를 통해 접근하기 때문에 O(1)

- **삽입 속도** : 임시 배열을 생성해 복사하므로 O(n)

- **삭제 속도** : 임시 배열을 생성해 복사하므로 O(n)

#### LinkedList

![img](https://media.vlpt.us/images/adam2/post/3a7e12f4-aa04-4650-87fd-d5dc8c524fbc/image.png)

- 노드 간에 연결(link)을 통해서 리스트로 구현된 객체.

- 다음 노드의 위치 정보만 가지고 있으며 인덱스를 가지고 있지 않기 때문에 `순차 접근`만 가능(!= Random Access)

- 논리적 저장순서와 물리적 저장 순서가 다르기 때문에 데이터 검색 시 처음 노드부터 순회해야 한다. ` O(n)`

- 메모리 공간 상에서 각 노드들이 연속적으로 이루어져 있지 않고 흩어져 있음

- 사용자는 제일 첫번째 노드의 위치만 알고 있는 상태

- 노드 추가/삭제는 위치정보의 수정만으로 가능하기 때문에 성능이 좋음

  ![img](https://media.vlpt.us/images/adam2/post/fe15b837-a8c7-4be2-ac26-bf7aabaa9873/image.png)

  ![img](https://media.vlpt.us/images/adam2/post/39e70de3-ff85-4076-b598-c7997d4b6406/image.png)

- **접근 속도** : 처음부터 순차적으로 검색하기 때문에 O(n)

- **삽입 속도** : 맨 앞과 맨 뒤에 삽입하는 경우 O(1), 그렇지 않으면 위치를 찾아야 하기 때문에 O(n)

- **삭제 속도** : 원소를 찾아야 하기 때문에 O(n)이지만 다음 노드의 주소값만 바꾸면 되기 때문에 Array 보다 빠른 연산

</br>

#### Vector

- ArrayList와 동일한 내부 구조를 가지고 있다.
- Vector는 크기가 정적인 배열의 단점을 개선하기 위해 Java 1.0 버전에서 등장하였고, 이를 Java 1.2버전에서 개선시킨 것이 ArrayList임. => 기존에 작성된 소스와의 호환성을 위해서 남겨두고 있음.
  - ArrayList와 다르게 Vector는 동기화를 지원 => 멀티 스레드 환경에서 사용
  - 스레드가 1개일때도 동기화를 하기 때문에 ArrayList보다 성능이 떨어짐. (ArrayList는 자동 동기화 기능을 빼고, 옵션이 존재)

</br>

#### [참고]

> - https://velog.io/@adam2/Array%EC%99%80-List%EA%B7%B8%EB%A6%AC%EA%B3%A0-Java-List
> - https://wayhome25.github.io/cs/2017/04/17/cs-18-1/
> - https://cupjoo.tistory.com/44
> - https://nali21c.github.io/2018/09/03/locality/